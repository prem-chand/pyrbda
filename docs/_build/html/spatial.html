<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>spatial package &#8212; pyspatial 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=8d563738"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="spatial-package">
<h1>spatial package<a class="headerlink" href="#spatial-package" title="Link to this heading">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h2>
</section>
<section id="module-spatial.EnerMo">
<span id="spatial-enermo-module"></span><h2>spatial.EnerMo module<a class="headerlink" href="#module-spatial.EnerMo" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.EnerMo.EnerMo">
<span class="sig-prename descclassname"><span class="pre">spatial.EnerMo.</span></span><span class="sig-name descname"><span class="pre">EnerMo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/EnerMo.html#EnerMo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.EnerMo.EnerMo" title="Link to this definition">¶</a></dt>
<dd><p>Calculate energy, momentum and related quantities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>q</strong> – Joint position vector</p></li>
<li><p><strong>qd</strong> – Joint velocity vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Structure containing:</dt><dd><ul class="simple">
<li><p>KE: Kinetic energy of the system</p></li>
<li><p>PE: Potential energy of the system</p></li>
<li><p>htot: Total spatial momentum</p></li>
<li><p>Itot: Total spatial inertia</p></li>
<li><p>cm: Position of center of mass</p></li>
<li><p>vcm: Linear velocity of center of mass</p></li>
<li><p>Pjt: Joint positions in base coordinates</p></li>
<li><p>Tr: Transformation matrices</p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ret</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.FDab">
<span id="spatial-fdab-module"></span><h2>spatial.FDab module<a class="headerlink" href="#module-spatial.FDab" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.FDab.FDab">
<span class="sig-prename descclassname"><span class="pre">spatial.FDab.</span></span><span class="sig-name descname"><span class="pre">FDab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/FDab.html#FDab"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.FDab.FDab" title="Link to this definition">¶</a></dt>
<dd><p>Forward Dynamics via Articulated-Body Algorithm.</p>
<p>Calculates forward dynamics of a kinematic tree using the
articulated-body algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>q</strong> – Joint position vector</p></li>
<li><p><strong>qd</strong> – Joint velocity vector</p></li>
<li><p><strong>tau</strong> – Joint force vector</p></li>
<li><p><strong>f_ext</strong> – Optional external forces</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint acceleration vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qdd</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.FDcrb">
<span id="spatial-fdcrb-module"></span><h2>spatial.FDcrb module<a class="headerlink" href="#module-spatial.FDcrb" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.FDcrb.FDcrb">
<span class="sig-prename descclassname"><span class="pre">spatial.FDcrb.</span></span><span class="sig-name descname"><span class="pre">FDcrb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/FDcrb.html#FDcrb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.FDcrb.FDcrb" title="Link to this definition">¶</a></dt>
<dd><p>Forward Dynamics via Composite-Rigid-Body Algorithm.</p>
<p>Calculates forward dynamics of a kinematic tree using the
composite-rigid-body algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>q</strong> – Joint position vector</p></li>
<li><p><strong>qd</strong> – Joint velocity vector</p></li>
<li><p><strong>tau</strong> – Joint force vector</p></li>
<li><p><strong>f_ext</strong> – Optional external forces</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint acceleration vector</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qdd</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.FDfb">
<span id="spatial-fdfb-module"></span><h2>spatial.FDfb module<a class="headerlink" href="#module-spatial.FDfb" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.FDfb.FDfb">
<span class="sig-prename descclassname"><span class="pre">spatial.FDfb.</span></span><span class="sig-name descname"><span class="pre">FDfb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xfb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/FDfb.html#FDfb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.FDfb.FDfb" title="Link to this definition">¶</a></dt>
<dd><p>Floating-Base Forward Dynamics via Articulated-Body Algorithm.</p>
<p>Calculates forward dynamics of floating-base kinematic tree avoiding
kinematic singularity in the six-joint chain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>xfb</strong> – 13-element state vector [quat_fb; pos_fb; vel_fb]</p></li>
<li><p><strong>q</strong> – Joint positions (real joints, 7 onwards)</p></li>
<li><p><strong>qd</strong> – Joint velocities</p></li>
<li><p><strong>tau</strong> – Joint forces</p></li>
<li><p><strong>f_ext</strong> – Optional external forces {nb_bodies} (first 5 ignored)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Time-derivative of xfb
qdd: Joint accelerations</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xdfb</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.FDgq">
<span id="spatial-fdgq-module"></span><h2>spatial.FDgq module<a class="headerlink" href="#module-spatial.FDgq" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.FDgq.FDgq">
<span class="sig-prename descclassname"><span class="pre">spatial.FDgq.</span></span><span class="sig-name descname"><span class="pre">FDgq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/FDgq.html#FDgq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.FDgq.FDgq" title="Link to this definition">¶</a></dt>
<dd><p>Forward Dynamics via CRBA + constraint function gamma_q.</p>
<p>Calculates forward dynamics of a kinematic tree subject to kinematic
constraints defined in model.gamma_q.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure with gamma_q method</p></li>
<li><p><strong>q</strong> – Joint position vector</p></li>
<li><p><strong>qd</strong> – Joint velocity vector</p></li>
<li><p><strong>tau</strong> – Joint force vector</p></li>
<li><p><strong>f_ext</strong> – Optional external forces</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint acceleration vector with constraint stabilization</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qdd</p>
</dd>
</dl>
<dl class="simple">
<dt>Note: q and qd don’t need to satisfy constraints exactly but should be close.</dt><dd><p>qdd typically includes constraint-stabilization component.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.Fpt">
<span id="spatial-fpt-module"></span><h2>spatial.Fpt module<a class="headerlink" href="#module-spatial.Fpt" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.Fpt.Fpt">
<span class="sig-prename descclassname"><span class="pre">spatial.Fpt.</span></span><span class="sig-name descname"><span class="pre">Fpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/Fpt.html#Fpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.Fpt.Fpt" title="Link to this definition">¶</a></dt>
<dd><p>Convert forces at points to spatial/planar forces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fp</strong> – Linear forces (3×n for 3D, 2×n for 2D)</p></li>
<li><p><strong>p</strong> – Points where forces act (3×n for 3D, 2×n for 2D)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Equivalent spatial/planar forces (6×n for 3D, 3×n for 2D)</dt><dd><p>where f[:,i] is equivalent to fp[:,i] acting at p[:,i]</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>f</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.HD">
<span id="spatial-hd-module"></span><h2>spatial.HD module<a class="headerlink" href="#module-spatial.HD" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.HD.HD">
<span class="sig-prename descclassname"><span class="pre">spatial.HD.</span></span><span class="sig-name descname"><span class="pre">HD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/HD.html#HD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.HD.HD" title="Link to this definition">¶</a></dt>
<dd><p>Articulated-Body Hybrid Dynamics Algorithm.</p>
<p>Calculates hybrid dynamics of a kinematic tree using the articulated-body algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>fd</strong> – Boolean array (fd[i]=True for forward-dynamics joints)</p></li>
<li><p><strong>q</strong> – Joint positions</p></li>
<li><p><strong>qd</strong> – Joint velocities</p></li>
<li><p><strong>qdd</strong> – Joint accelerations (used when fd[i]=False)</p></li>
<li><p><strong>tau</strong> – Joint forces (used when fd[i]=True)</p></li>
<li><p><strong>f_ext</strong> – Optional external forces</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint accelerations (calculated where fd[i]=True)
tau_out: Joint forces (calculated where fd[i]=False)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qdd_out</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.He">
<span id="spatial-he-module"></span><h2>spatial.He module<a class="headerlink" href="#module-spatial.He" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.He.He">
<span class="sig-prename descclassname"><span class="pre">spatial.He.</span></span><span class="sig-name descname"><span class="pre">He</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/He.html#He"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.He.He" title="Link to this definition">¶</a></dt>
<dd><p>Calculate joint-space inertia matrix.</p>
<p>Calculates the joint-space inertia matrix H(q) from the equation of motion:
tau = H(q)qdd + C(q,qd,f_ext)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>q</strong> – Joint position vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint-space inertia matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>He</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.ID">
<span id="spatial-id-module"></span><h2>spatial.ID module<a class="headerlink" href="#module-spatial.ID" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.ID.ID">
<span class="sig-prename descclassname"><span class="pre">spatial.ID.</span></span><span class="sig-name descname"><span class="pre">ID</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/ID.html#ID"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.ID.ID" title="Link to this definition">¶</a></dt>
<dd><p>Inverse Dynamics via Recursive Newton-Euler Algorithm.</p>
<p>Calculates the inverse dynamics of a kinematic tree using the recursive
Newton-Euler algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>q</strong> – Joint positions</p></li>
<li><p><strong>qd</strong> – Joint velocities</p></li>
<li><p><strong>qdd</strong> – Joint accelerations</p></li>
<li><p><strong>f_ext</strong> – Optional external forces acting on the bodies</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint forces required to achieve the motion</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.IDfb">
<span id="spatial-idfb-module"></span><h2>spatial.IDfb module<a class="headerlink" href="#module-spatial.IDfb" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.IDfb.IDfb">
<span class="sig-prename descclassname"><span class="pre">spatial.IDfb.</span></span><span class="sig-name descname"><span class="pre">IDfb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xfb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/IDfb.html#IDfb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.IDfb.IDfb" title="Link to this definition">¶</a></dt>
<dd><p>Floating-Base Inverse Dynamics (=Hybrid Dynamics).</p>
<p>Calculates inverse dynamics of floating-base kinematic tree using
singularity-free representation (Table 9.6 RBDA).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Robot model structure</p></li>
<li><p><strong>xfb</strong> – 13-element state vector [quat_fb; pos_fb; vel_fb]</p></li>
<li><p><strong>q</strong> – Joint positions (real joints, 7 onwards)</p></li>
<li><p><strong>qd</strong> – Joint velocities</p></li>
<li><p><strong>qdd</strong> – Joint accelerations</p></li>
<li><p><strong>f_ext</strong> – Optional external forces {nb_bodies} (first 5 ignored)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Time-derivative of xfb
tau: Joint forces to achieve qdd</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xdfb</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.InertiaMatrix">
<span id="spatial-inertiamatrix-module"></span><h2>spatial.InertiaMatrix module<a class="headerlink" href="#module-spatial.InertiaMatrix" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.InertiaMatrix.InertiaMatrix">
<span class="sig-prename descclassname"><span class="pre">spatial.InertiaMatrix.</span></span><span class="sig-name descname"><span class="pre">InertiaMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xup</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/InertiaMatrix.html#InertiaMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.InertiaMatrix.InertiaMatrix" title="Link to this definition">¶</a></dt>
<dd><p>Calculate the joint-space inertia matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – Object containing necessary methods</p></li>
<li><p><strong>sys</strong> – System containing model information</p></li>
<li><p><strong>q</strong> – Joint position vector</p></li>
<li><p><strong>S</strong> – Dictionary of motion subspaces</p></li>
<li><p><strong>Xup</strong> – Dictionary of coordinate transforms</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint-space inertia matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>H</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.LTDL">
<span id="spatial-ltdl-module"></span><h2>spatial.LTDL module<a class="headerlink" href="#module-spatial.LTDL" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.LTDL.LTDL">
<span class="sig-prename descclassname"><span class="pre">spatial.LTDL.</span></span><span class="sig-name descname"><span class="pre">LTDL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/LTDL.html#LTDL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.LTDL.LTDL" title="Link to this definition">¶</a></dt>
<dd><p>Factorize H -&gt; L’<a href="#id1"><span class="problematic" id="id2">*</span></a>D*L exploiting branch-induced sparsity.</p>
<p>Computes unit-lower-triangular matrix L and diagonal matrix D satisfying
L’<a href="#id3"><span class="problematic" id="id4">*</span></a>D*L = H, where H is a symmetric, positive-definite matrix with
branch-induced sparsity pattern determined by lambda.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> – Symmetric positive-definite matrix (e.g., joint-space inertia matrix)</p></li>
<li><p><strong>lambda_arr</strong> – Parent array satisfying 0 &lt;= lambda[i] &lt; i for all i</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Unit-lower-triangular matrix
D: Diagonal matrix
Such that L.T &#64; D &#64; L = H</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>L</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.LTL">
<span id="spatial-ltl-module"></span><h2>spatial.LTL module<a class="headerlink" href="#module-spatial.LTL" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.LTL.LTL">
<span class="sig-prename descclassname"><span class="pre">spatial.LTL.</span></span><span class="sig-name descname"><span class="pre">LTL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/LTL.html#LTL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.LTL.LTL" title="Link to this definition">¶</a></dt>
<dd><p>Factorize H -&gt; L’<a href="#id5"><span class="problematic" id="id6">*</span></a>L exploiting branch-induced sparsity.</p>
<p>Computes lower-triangular matrix L satisfying L’<a href="#id7"><span class="problematic" id="id8">*</span></a>L = H, where H is a symmetric,
positive-definite matrix with branch-induced sparsity pattern determined by lambda.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> – Symmetric positive-definite matrix (e.g., joint-space inertia matrix)</p></li>
<li><p><strong>lambda_arr</strong> – Parent array satisfying 0 &lt;= lambda[i] &lt; i for all i</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Lower-triangular matrix such that L.T &#64; L = H</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>L</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.Vpt">
<span id="spatial-vpt-module"></span><h2>spatial.Vpt module<a class="headerlink" href="#module-spatial.Vpt" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.Vpt.Vpt">
<span class="sig-prename descclassname"><span class="pre">spatial.Vpt.</span></span><span class="sig-name descname"><span class="pre">Vpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/Vpt.html#Vpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.Vpt.Vpt" title="Link to this definition">¶</a></dt>
<dd><p>Calculate linear velocities at points from spatial/planar velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> – Spatial/planar velocities (6×1 or 6×n for 3D, 3×1 or 3×n for 2D)</p></li>
<li><p><strong>p</strong> – Points (3×n for 3D, 2×n for 2D)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Linear velocities at points (3×n for 3D, 2×n for 2D)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vp</p>
</dd>
</dl>
<dl class="simple">
<dt>Note: If v is a single vector, it applies to all points in p.</dt><dd><p>Otherwise, vp[:,i] is calculated from v[:,i] and p[:,i].</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.Xpt">
<span id="spatial-xpt-module"></span><h2>spatial.Xpt module<a class="headerlink" href="#module-spatial.Xpt" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.Xpt.Xpt">
<span class="sig-prename descclassname"><span class="pre">spatial.Xpt.</span></span><span class="sig-name descname"><span class="pre">Xpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/Xpt.html#Xpt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.Xpt.Xpt" title="Link to this definition">¶</a></dt>
<dd><p>Apply Plucker/planar coordinate transform to 2D/3D points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – Coordinate transform matrix (6x6 for Plucker, 3x3 for planar)</p></li>
<li><p><strong>p</strong> – Points matrix (3×n for 3D points, 2×n for 2D points)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed points in new coordinates</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xp</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.XtoV">
<span id="spatial-xtov-module"></span><h2>spatial.XtoV module<a class="headerlink" href="#module-spatial.XtoV" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.XtoV.XtoV">
<span class="sig-prename descclassname"><span class="pre">spatial.XtoV.</span></span><span class="sig-name descname"><span class="pre">XtoV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/XtoV.html#XtoV"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.XtoV.XtoV" title="Link to this definition">¶</a></dt>
<dd><p>Obtain spatial/planar vector from small-angle transform.</p>
<p>Interprets X as the coordinate transform from A to B coordinates, which
implicitly defines the location of frame B relative to frame A. Calculates
the velocity of a third frame, C(t), that travels at constant velocity
from frame A to B in one time unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> – Coordinate transform matrix (6x6 for spatial, 3x3 for planar)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Velocity vector (6D for spatial, 3D for planar)</dt><dd><p>This is exact only if frames A and B are parallel</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>v</p>
</dd>
</dl>
<dl class="simple">
<dt>Note: The return value is an invariant of X (i.e., v=X&#64;v), and can be</dt><dd><p>regarded as being expressed in both A and B coordinates.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.crf">
<span id="spatial-crf-module"></span><h2>spatial.crf module<a class="headerlink" href="#module-spatial.crf" title="Link to this heading">¶</a></h2>
<p>Spatial/planar cross-product operator (force).</p>
<p>Calculates the 6x6 (or 3x3) matrix such that crf(v)*f is the cross product
of the motion vector v with the force vector f.</p>
<dl class="field-list simple">
<dt class="field-odd">param v<span class="colon">:</span></dt>
<dd class="field-odd"><p>Motion vector (6D for spatial, 3D for planar)</p>
</dd>
<dt class="field-even">returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cross-product operator matrix (6x6 for spatial, 3x3 for planar)</p>
</dd>
<dt class="field-odd">rtype<span class="colon">:</span></dt>
<dd class="field-odd"><p>vcross</p>
</dd>
</dl>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.crf.crf">
<span class="sig-prename descclassname"><span class="pre">spatial.crf.</span></span><span class="sig-name descname"><span class="pre">crf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/crf.html#crf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.crf.crf" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-spatial.crm">
<span id="spatial-crm-module"></span><h2>spatial.crm module<a class="headerlink" href="#module-spatial.crm" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.crm.crm">
<span class="sig-prename descclassname"><span class="pre">spatial.crm.</span></span><span class="sig-name descname"><span class="pre">crm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/crm.html#crm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.crm.crm" title="Link to this definition">¶</a></dt>
<dd><p>Spatial/planar cross-product operator (motion).</p>
<p>Calculates the 6x6 (or 3x3) matrix such that crm(v)*m is the cross product
of the motion vectors v and m.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> – Motion vector (6D for spatial, 3D for planar)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cross-product operator matrix (6x6 for spatial, 3x3 for planar)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>vcross</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.expandLambda">
<span id="spatial-expandlambda-module"></span><h2>spatial.expandLambda module<a class="headerlink" href="#module-spatial.expandLambda" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.expandLambda.expandLambda">
<span class="sig-prename descclassname"><span class="pre">spatial.expandLambda.</span></span><span class="sig-name descname"><span class="pre">expandLambda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/expandLambda.html#expandLambda"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.expandLambda.expandLambda" title="Link to this definition">¶</a></dt>
<dd><p>Expand a parent array for use in sparse factorization algorithms.</p>
<p>Calculates the expanded parent array from a given parent array and an array
of joint motion freedoms. nf[i] is the degree of motion freedom allowed by joint i.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lambda_arr</strong> – Original parent array</p></li>
<li><p><strong>nf</strong> – Array of joint motion freedoms</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Expanded parent array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>newLambda</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.fbanim">
<span id="spatial-fbanim-module"></span><h2>spatial.fbanim module<a class="headerlink" href="#module-spatial.fbanim" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.fbanim.fbanim">
<span class="sig-prename descclassname"><span class="pre">spatial.fbanim.</span></span><span class="sig-name descname"><span class="pre">fbanim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Qr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/fbanim.html#fbanim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.fbanim.fbanim" title="Link to this definition">¶</a></dt>
<dd><p>Floating Base Inverse Kinematics for Animation.</p>
<p>Calculates joint position data for smooth animations by removing discontinuities
from joint angles when they wrap around or pass through kinematic singularities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – State vector array (13×N, 13×1×N, 7×N, or 7×1×N) where each column contains
at least the first 7 elements of a 13-element singularity-free state vector</p></li>
<li><p><strong>Qr</strong> – Optional joint position data (M×N or M×1×N) for real joints in mechanism</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Joint position matrix (6×N or (6+M)×N) containing floating base joint data</dt><dd><p>and optionally the real joint data</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Q</p>
</dd>
</dl>
<dl class="simple">
<dt>Note: Algorithm assumes less than π/2 changes between consecutive columns</dt><dd><p>(except at singularities). Visible glitches may still occur if violated.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.fbkin">
<span id="spatial-fbkin-module"></span><h2>spatial.fbkin module<a class="headerlink" href="#module-spatial.fbkin" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.fbkin.fbkin">
<span class="sig-prename descclassname"><span class="pre">spatial.fbkin.</span></span><span class="sig-name descname"><span class="pre">fbkin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/fbkin.html#fbkin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.fbkin.fbkin" title="Link to this definition">¶</a></dt>
<dd><p>Forward and Inverse Kinematics of Floating Base.</p>
<p>Multiple usage modes:
1. [x,xd] = fbkin(q,qd,qdd): Forward kinematics
2. [q,qd,qdd] = fbkin(x,xd): Inverse kinematics
3. x = fbkin(q,qd) or [q,qd] = fbkin(x): Without acceleration
4. p = fbkin(q) or q = fbkin(p): Position only</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i1</strong> – First input (q, x, or p)</p></li>
<li><p><strong>i2</strong> – Optional second input (qd or xd)</p></li>
<li><p><strong>i3</strong> – Optional third input (qdd)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Various outputs depending on input mode</p>
</dd>
</dl>
<p>Note: Singularities occur when q[4] = ±π/2</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.fbkin.fwdkin">
<span class="sig-prename descclassname"><span class="pre">spatial.fbkin.</span></span><span class="sig-name descname"><span class="pre">fwdkin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qdd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/fbkin.html#fwdkin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.fbkin.fwdkin" title="Link to this definition">¶</a></dt>
<dd><p>Forward kinematics calculation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.fbkin.invkin">
<span class="sig-prename descclassname"><span class="pre">spatial.fbkin.</span></span><span class="sig-name descname"><span class="pre">invkin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/fbkin.html#invkin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.fbkin.invkin" title="Link to this definition">¶</a></dt>
<dd><p>Inverse kinematics calculation.</p>
</dd></dl>

</section>
<section id="module-spatial.floatbase">
<span id="spatial-floatbase-module"></span><h2>spatial.floatbase module<a class="headerlink" href="#module-spatial.floatbase" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.floatbase.floatbase">
<span class="sig-prename descclassname"><span class="pre">spatial.floatbase.</span></span><span class="sig-name descname"><span class="pre">floatbase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/floatbase.html#floatbase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.floatbase.floatbase" title="Link to this definition">¶</a></dt>
<dd><p>Construct the floating-base equivalent of a fixed-base model.</p>
<p>Converts a fixed-base spatial kinematic tree to a floating-base kinematic tree:
- Old body 1 becomes new body 6 (floating base)
- Old joint 1 is discarded
- Six new joints added (3 prismatic, 3 revolute; x,y,z order)
- Five new zero-mass bodies added (1-5) to connect new joints
- All other bodies/joints preserved but numbers incremented by 5</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> – Fixed-base model structure containing at least:
- NB: Number of bodies
- jtype: List of joint types
- parent: List of parent body indices
- Xtree: List of coordinate transforms
- I: List of spatial inertias</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Floating-base model with same structure as input</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fbmodel</p>
</dd>
</dl>
<p>Caution: Singularity occurs when q[4] = ±π/2</p>
</dd></dl>

</section>
<section id="module-spatial.get_gravity">
<span id="spatial-get-gravity-module"></span><h2>spatial.get_gravity module<a class="headerlink" href="#module-spatial.get_gravity" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.get_gravity.get_gravity">
<span class="sig-prename descclassname"><span class="pre">spatial.get_gravity.</span></span><span class="sig-name descname"><span class="pre">get_gravity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/get_gravity.html#get_gravity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.get_gravity.get_gravity" title="Link to this definition">¶</a></dt>
<dd><p>Get spatial/planar gravitational acceleration vector for given model.</p>
<p>Computes gravitational acceleration vector for dynamics calculations.
Returns either spatial or planar vector based on model type.
Uses model.gravity if present, otherwise defaults to:
- [0,0,-9.81] for spatial models
- [0,0] for planar models</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> – Model structure containing at least:
- Xtree: List of transforms (used to determine if model is planar)
- gravity: Optional field specifying gravitational acceleration</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Gravitational acceleration vector (spatial or planar)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>a_grav</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.jcalc">
<span id="spatial-jcalc-module"></span><h2>spatial.jcalc module<a class="headerlink" href="#module-spatial.jcalc" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.jcalc.jcalc">
<span class="sig-prename descclassname"><span class="pre">spatial.jcalc.</span></span><span class="sig-name descname"><span class="pre">jcalc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">jtyp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/jcalc.html#jcalc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.jcalc.jcalc" title="Link to this definition">¶</a></dt>
<dd><p>Calculate joint transform and motion subspace matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jtyp</strong> – Either a string or a dict containing joint type code.
For parameterized joints (e.g. helical), jtyp must be a dict
with ‘code’ and ‘pars’ fields.</p></li>
<li><p><strong>q</strong> – Joint position variable</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Joint transform matrix
S: Motion subspace matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Xj</p>
</dd>
</dl>
<dl class="simple">
<dt>Joint types:</dt><dd><p>‘Rx’: Revolute X axis
‘Ry’: Revolute Y axis
‘R’,’Rz’: Revolute Z axis
‘Px’: Prismatic X axis
‘Py’: Prismatic Y axis
‘P’,’Pz’: Prismatic Z axis
‘H’: Helical (Z axis)
‘r’: Planar revolute
‘px’: Planar prismatic X axis
‘py’: Planar prismatic Y axis</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.mcI">
<span id="spatial-mci-module"></span><h2>spatial.mcI module<a class="headerlink" href="#module-spatial.mcI" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.mcI.mcI">
<span class="sig-prename descclassname"><span class="pre">spatial.mcI.</span></span><span class="sig-name descname"><span class="pre">mcI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i3</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mcI.html#mcI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mcI.mcI" title="Link to this definition">¶</a></dt>
<dd><p>Convert between rigid-body inertia and mass, CoM and rotational inertia.</p>
<p>Two usage modes:
1. rbi = mcI(m, c, I): Convert mass, CoM, and inertia to rigid-body inertia matrix
2. m, c, I = mcI(rbi): Convert rigid-body inertia matrix to mass, CoM, and inertia</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i1</strong> – Either mass m or rigid-body inertia matrix rbi</p></li>
<li><p><strong>i2</strong> – Optional center of mass vector c</p></li>
<li><p><strong>i3</strong> – Optional rotational inertia I</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns rigid-body inertia matrix
If converting from rbi: returns mass, CoM vector, and rotational inertia</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If converting to rbi</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.mcI.mcI_to_rbi">
<span class="sig-prename descclassname"><span class="pre">spatial.mcI.</span></span><span class="sig-name descname"><span class="pre">mcI_to_rbi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mcI.html#mcI_to_rbi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mcI.mcI_to_rbi" title="Link to this definition">¶</a></dt>
<dd><p>Convert mass, CoM and rotational inertia to rigid-body inertia matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.mcI.rbi_to_mcI">
<span class="sig-prename descclassname"><span class="pre">spatial.mcI.</span></span><span class="sig-name descname"><span class="pre">rbi_to_mcI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rbi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mcI.html#rbi_to_mcI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mcI.rbi_to_mcI" title="Link to this definition">¶</a></dt>
<dd><p>Convert rigid-body inertia matrix to mass, CoM and rotational inertia.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.mcI.skew">
<span class="sig-prename descclassname"><span class="pre">spatial.mcI.</span></span><span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mcI.html#skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mcI.skew" title="Link to this definition">¶</a></dt>
<dd><p>Convert 3D vector to skew-symmetric matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.mcI.skewCustom">
<span class="sig-prename descclassname"><span class="pre">spatial.mcI.</span></span><span class="sig-name descname"><span class="pre">skewCustom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mC</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mcI.html#skewCustom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mcI.skewCustom" title="Link to this definition">¶</a></dt>
<dd><p>Extract vector from skew-symmetric matrix * mass.</p>
</dd></dl>

</section>
<section id="module-spatial.mpyH">
<span id="spatial-mpyh-module"></span><h2>spatial.mpyH module<a class="headerlink" href="#module-spatial.mpyH" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.mpyH.mpyH">
<span class="sig-prename descclassname"><span class="pre">spatial.mpyH.</span></span><span class="sig-name descname"><span class="pre">mpyH</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mpyH.html#mpyH"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mpyH.mpyH" title="Link to this definition">¶</a></dt>
<dd><p>Calculate H*x exploiting branch-induced sparsity in H.</p>
<p>Computes H*x where x is a vector and H is a symmetric, positive-definite matrix.
The nonzero elements on row i below the main diagonal appear only in columns
lambda(i), lambda(lambda(i)), etc. This is the pattern of branch-induced sparsity.
H and lambda can be regarded as the joint-space inertia matrix and parent array
of a kinematic tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> – Symmetric positive-definite matrix with branch-induced sparsity</p></li>
<li><p><strong>lambda_arr</strong> – Parent array (must satisfy 0 &lt;= lambda[i] &lt; i for all i)</p></li>
<li><p><strong>x</strong> – Input vector to multiply</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of H*x multiplication</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>y</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.mpyL">
<span id="spatial-mpyl-module"></span><h2>spatial.mpyL module<a class="headerlink" href="#module-spatial.mpyL" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.mpyL.mpyL">
<span class="sig-prename descclassname"><span class="pre">spatial.mpyL.</span></span><span class="sig-name descname"><span class="pre">mpyL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mpyL.html#mpyL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mpyL.mpyL" title="Link to this definition">¶</a></dt>
<dd><p>Multiply vector by L factor from LTL or LTDL.</p>
<p>Computes L*x where L is the lower-triangular matrix from either LTL or LTDL
and lambda_arr is the parent array describing the sparsity pattern in L.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> – Lower-triangular matrix</p></li>
<li><p><strong>lambda_arr</strong> – Parent array describing sparsity pattern</p></li>
<li><p><strong>x</strong> – Input vector to multiply</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of L*x multiplication</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>y</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.mpyLi">
<span id="spatial-mpyli-module"></span><h2>spatial.mpyLi module<a class="headerlink" href="#module-spatial.mpyLi" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.mpyLi.mpyLi">
<span class="sig-prename descclassname"><span class="pre">spatial.mpyLi.</span></span><span class="sig-name descname"><span class="pre">mpyLi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mpyLi.html#mpyLi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mpyLi.mpyLi" title="Link to this definition">¶</a></dt>
<dd><p>Multiply vector by inverse of L factor from LTL or LTDL.</p>
<p>Computes inv(L)*x where L is the lower-triangular matrix from either LTL or LTDL
and lambda_arr is the parent array describing the sparsity pattern in L.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> – Lower-triangular matrix</p></li>
<li><p><strong>lambda_arr</strong> – Parent array describing sparsity pattern</p></li>
<li><p><strong>x</strong> – Input vector to multiply</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of inv(L)*x multiplication</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>y</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.mpyLit">
<span id="spatial-mpylit-module"></span><h2>spatial.mpyLit module<a class="headerlink" href="#module-spatial.mpyLit" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.mpyLit.mpyLit">
<span class="sig-prename descclassname"><span class="pre">spatial.mpyLit.</span></span><span class="sig-name descname"><span class="pre">mpyLit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mpyLit.html#mpyLit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mpyLit.mpyLit" title="Link to this definition">¶</a></dt>
<dd><p>Multiply vector by inverse transpose of L factor from LTL or LTDL.</p>
<p>Computes inv(L’)*x where L is the lower-triangular matrix from either LTL or LTDL
and lambda_arr is the parent array describing the sparsity pattern in L.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> – Lower-triangular matrix</p></li>
<li><p><strong>lambda_arr</strong> – Parent array describing sparsity pattern</p></li>
<li><p><strong>x</strong> – Input vector to multiply</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of inv(L’)*x multiplication</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>y</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.mpyLt">
<span id="spatial-mpylt-module"></span><h2>spatial.mpyLt module<a class="headerlink" href="#module-spatial.mpyLt" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.mpyLt.mpyLt">
<span class="sig-prename descclassname"><span class="pre">spatial.mpyLt.</span></span><span class="sig-name descname"><span class="pre">mpyLt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/mpyLt.html#mpyLt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.mpyLt.mpyLt" title="Link to this definition">¶</a></dt>
<dd><p>Multiply vector by transpose of L factor from LTL or LTDL.</p>
<p>Computes L’<a href="#id9"><span class="problematic" id="id10">*</span></a>x where L is the lower-triangular matrix from either LTL or LTDL
and lambda_arr is the parent array describing the sparsity pattern in L.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> – Lower-triangular matrix</p></li>
<li><p><strong>lambda_arr</strong> – Parent array describing sparsity pattern</p></li>
<li><p><strong>x</strong> – Input vector to multiply</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Result of L’<a href="#id11"><span class="problematic" id="id12">*</span></a>x multiplication</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>y</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.plnr">
<span id="spatial-plnr-module"></span><h2>spatial.plnr module<a class="headerlink" href="#module-spatial.plnr" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.plnr.plnr">
<span class="sig-prename descclassname"><span class="pre">spatial.plnr.</span></span><span class="sig-name descname"><span class="pre">plnr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/plnr.html#plnr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.plnr.plnr" title="Link to this definition">¶</a></dt>
<dd><p>Compose/decompose planar-vector coordinate transform.</p>
<p>Two usage modes:
1. X = plnr(theta, r): Compose transform X from angle theta and vector r
2. theta, r = plnr(X): Decompose transform X into angle theta and vector r</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i1</strong> – Either rotation angle theta (in radians) or transform matrix X</p></li>
<li><p><strong>i2</strong> – Optional 2D position vector r (if composing transform)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns transform matrix X
If decomposing (X given): returns theta, r</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If composing (theta, r given)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-spatial.pluho">
<span id="spatial-pluho-module"></span><h2>spatial.pluho module<a class="headerlink" href="#module-spatial.pluho" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.pluho.pluho">
<span class="sig-prename descclassname"><span class="pre">spatial.pluho.</span></span><span class="sig-name descname"><span class="pre">pluho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix_in</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/pluho.html#pluho"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.pluho.pluho" title="Link to this definition">¶</a></dt>
<dd><p>Convert between Plucker and 4x4 homogeneous coordinate transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix_in</strong> – Either a 6x6 Plucker matrix (X) or a 4x4 homogeneous transform matrix (T)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>returns 4x4 homogeneous transform matrix
If input is 4x4: returns 6x6 Plucker matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>If input is 6x6</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.pluho.skew">
<span class="sig-prename descclassname"><span class="pre">spatial.pluho.</span></span><span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/pluho.html#skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.pluho.skew" title="Link to this definition">¶</a></dt>
<dd><p>Convert a 3D vector to a skew-symmetric matrix.</p>
</dd></dl>

</section>
<section id="module-spatial.plux">
<span id="spatial-plux-module"></span><h2>spatial.plux module<a class="headerlink" href="#module-spatial.plux" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.plux.plux">
<span class="sig-prename descclassname"><span class="pre">spatial.plux.</span></span><span class="sig-name descname"><span class="pre">plux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/plux.html#plux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.plux.plux" title="Link to this definition">¶</a></dt>
<dd><p>plux  compose/decompose Plucker coordinate transform.
X=plux(E,r) and [E,r]=plux(X) compose a Plucker coordinate transform X
from its component parts E and r, and decompose it into those parts,
respectively. E is a 3x3 rotational coordinate transform and r is a 3D
vector. r is returned as a column vector, but it can be supplied as a
row or column vector. X is a coordinate transform corresponding to a
shift of origin by an amount specified by r, followed by a rotation about
the new origin as specified by E. For example, plux(rx(1),[2 3 4]) makes
the same transform as rotx(1)*xlt([2 3 4]). If two arguments are
supplied then they are assumed to be E and r, otherwise X.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.plux.skew">
<span class="sig-prename descclassname"><span class="pre">spatial.plux.</span></span><span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/plux.html#skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.plux.skew" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-spatial.rotx">
<span id="spatial-rotx-module"></span><h2>spatial.rotx module<a class="headerlink" href="#module-spatial.rotx" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rotx.rotx">
<span class="sig-prename descclassname"><span class="pre">spatial.rotx.</span></span><span class="sig-name descname"><span class="pre">rotx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rotx.html#rotx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rotx.rotx" title="Link to this definition">¶</a></dt>
<dd><p>rotx  spatial coordinate transform (X-axis rotation).
rotx(theta) calculates the coordinate transform matrix from A to B
coordinates for spatial motion vectors, where coordinate frame B is
rotated by an angle theta (radians) relative to frame A about their
common X axis.</p>
</dd></dl>

</section>
<section id="module-spatial.roty">
<span id="spatial-roty-module"></span><h2>spatial.roty module<a class="headerlink" href="#module-spatial.roty" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.roty.roty">
<span class="sig-prename descclassname"><span class="pre">spatial.roty.</span></span><span class="sig-name descname"><span class="pre">roty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/roty.html#roty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.roty.roty" title="Link to this definition">¶</a></dt>
<dd><p>roty  spatial coordinate transform (Y-axis rotation).
roty(theta) calculates the coordinate transform matrix from A to B
coordinates for spatial motion vectors, where coordinate frame B is
rotated by an angle theta (radians) relative to frame A about their
common Y axis.</p>
</dd></dl>

</section>
<section id="module-spatial.rotz">
<span id="spatial-rotz-module"></span><h2>spatial.rotz module<a class="headerlink" href="#module-spatial.rotz" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rotz.rotz">
<span class="sig-prename descclassname"><span class="pre">spatial.rotz.</span></span><span class="sig-name descname"><span class="pre">rotz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rotz.html#rotz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rotz.rotz" title="Link to this definition">¶</a></dt>
<dd><p>rotz  spatial coordinate transform (Z-axis rotation).
rotz(theta) calculates the coordinate transform matrix from A to B
coordinates for spatial motion vectors, where coordinate frame B is
rotated by an angle theta (radians) relative to frame A about their
common Z axis.</p>
</dd></dl>

</section>
<section id="module-spatial.rq">
<span id="spatial-rq-module"></span><h2>spatial.rq module<a class="headerlink" href="#module-spatial.rq" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rq.Etoq">
<span class="sig-prename descclassname"><span class="pre">spatial.rq.</span></span><span class="sig-name descname"><span class="pre">Etoq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rq.html#Etoq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rq.Etoq" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.rq.qtoE">
<span class="sig-prename descclassname"><span class="pre">spatial.rq.</span></span><span class="sig-name descname"><span class="pre">qtoE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rq.html#qtoE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rq.qtoE" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.rq.rq">
<span class="sig-prename descclassname"><span class="pre">spatial.rq.</span></span><span class="sig-name descname"><span class="pre">rq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rq.html#rq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rq.rq" title="Link to this definition">¶</a></dt>
<dd><p>rq  unit quaternion &lt;–&gt; 3x3 coordinate rotation matrix
E=rq(q) and q=rq(E) convert between a unit quaternion q, representing
the orientation of a coordinate frame B relative to frame A, and the 3x3
coordinate rotation matrix E that transforms from A to B coordinates.
For example, if B is rotated relative to A about their common X axis by
an angle h, then q=[cos(h/2);sin(h/2);0;0] and rq(q) produces the same
matrix as rx(h). If the argument is a 3x3 matrix then it is assumed to
be E, otherwise it is assumed to be q. rq(E) expects E to be accurately
orthonormal, and returns a quaternion in a 4x1 matrix; but rq(q) accepts
any nonzero quaternion, contained in either a row or a column vector, and
normalizes it before use. As both q and -q represent the same rotation,
rq(E) returns the value that satisfies q(1)&gt;0. If q(1)==0 then it picks
the value such that the largest-magnitude element is positive. In the
event of a tie, the smaller index wins.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.rq.skew">
<span class="sig-prename descclassname"><span class="pre">spatial.rq.</span></span><span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rq.html#skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rq.skew" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-spatial.rqd">
<span id="spatial-rqd-module"></span><h2>spatial.rqd module<a class="headerlink" href="#module-spatial.rqd" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rqd.rqd">
<span class="sig-prename descclassname"><span class="pre">spatial.rqd.</span></span><span class="sig-name descname"><span class="pre">rqd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rqd.html#rqd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rqd.rqd" title="Link to this definition">¶</a></dt>
<dd><p>rqd  derivative of unit quaternion from angular velocity
qd=rqd(wA,q) and qd=rqd(q,wB) calculate the derivative of a unit
quaternion, q, representing the orientation of a coordinate frame B
relative to frame A, given the angular velocity w of B relative to A. If
w is expressed in A coordinates then use rqd(wA,q); and if w is expressed
in B coordinates then use rqd(q,wB). If the length of the first argument
is 4 then it is assumed to be q, otherwise it is assumed to be wA. The
return value is a column vector, but the arguments can be row or column
vectors. It is not necessary for <a href="#id13"><span class="problematic" id="id14">|q|</span></a> to be exactly 1. If <a href="#id15"><span class="problematic" id="id16">|q|~=1 then qd
contains a magnitude-stabilizing term that will cause |q|</span></a> to converge
towards 1 if q is obtained by numerical integration of qd.</p>
</dd></dl>

</section>
<section id="module-spatial.rv">
<span id="spatial-rv-module"></span><h2>spatial.rv module<a class="headerlink" href="#module-spatial.rv" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rv.Etov">
<span class="sig-prename descclassname"><span class="pre">spatial.rv.</span></span><span class="sig-name descname"><span class="pre">Etov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rv.html#Etov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rv.Etov" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.rv.rv">
<span class="sig-prename descclassname"><span class="pre">spatial.rv.</span></span><span class="sig-name descname"><span class="pre">rv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rv.html#rv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rv.rv" title="Link to this definition">¶</a></dt>
<dd><p>rv  3D rotation vector &lt;–&gt; 3x3 coordinate rotation matrix
E=rv(v) and v=rv(E) convert between a rotation vector v, whose magnitude
and direction describe the angle and axis of rotation of a coordinate
frame B relative to frame A, and the 3x3 coordinate rotation matrix E
that transforms from A to B coordinates. For example, if v=[theta;0;0]
then rv(v) produces the same matrix as rx(theta). If the argument is a
3x3 matrix then it is assumed to be E, otherwise it is assumed to be v.
rv(E) expects E to be accurately orthonormal, and returns a column vector
with a magnitude in the range [0,pi]. If the magnitude is exactly pi
then the sign of the return value is unpredictable, since pi*u and -pi*u,
where u is any unit vector, both represent the same rotation. rv(v) will
accept a row or column vector of any magnitude.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.rv.skew">
<span class="sig-prename descclassname"><span class="pre">spatial.rv.</span></span><span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rv.html#skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rv.skew" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="spatial.rv.vtoE">
<span class="sig-prename descclassname"><span class="pre">spatial.rv.</span></span><span class="sig-name descname"><span class="pre">vtoE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rv.html#vtoE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rv.vtoE" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
<section id="module-spatial.rx">
<span id="spatial-rx-module"></span><h2>spatial.rx module<a class="headerlink" href="#module-spatial.rx" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rx.rx">
<span class="sig-prename descclassname"><span class="pre">spatial.rx.</span></span><span class="sig-name descname"><span class="pre">rx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rx.html#rx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rx.rx" title="Link to this definition">¶</a></dt>
<dd><p>rx  3x3 coordinate rotation (X-axis)
rx(theta) calculates the 3x3 rotational coordinate transform matrix from
A to B coordinates, where coordinate frame B is rotated by an angle theta
(radians) relative to frame A about their common X axis.</p>
</dd></dl>

</section>
<section id="module-spatial.ry">
<span id="spatial-ry-module"></span><h2>spatial.ry module<a class="headerlink" href="#module-spatial.ry" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.ry.ry">
<span class="sig-prename descclassname"><span class="pre">spatial.ry.</span></span><span class="sig-name descname"><span class="pre">ry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/ry.html#ry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.ry.ry" title="Link to this definition">¶</a></dt>
<dd><p>ry  3x3 coordinate rotation (Y-axis)
ry(theta) calculates the 3x3 rotational coordinate transform matrix from
A to B coordinates, where coordinate frame B is rotated by an angle theta
(radians) relative to frame A about their common Y axis.</p>
</dd></dl>

</section>
<section id="module-spatial.rz">
<span id="spatial-rz-module"></span><h2>spatial.rz module<a class="headerlink" href="#module-spatial.rz" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.rz.rz">
<span class="sig-prename descclassname"><span class="pre">spatial.rz.</span></span><span class="sig-name descname"><span class="pre">rz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/rz.html#rz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.rz.rz" title="Link to this definition">¶</a></dt>
<dd><p>rz  3x3 coordinate rotation (Z-axis)
rz(theta) calculates the 3x3 rotational coordinate transform matrix from
A to B coordinates, where coordinate frame B is rotated by an angle theta
(radians) relative to frame A about their common Z axis.</p>
</dd></dl>

</section>
<section id="module-spatial.skew">
<span id="spatial-skew-module"></span><h2>spatial.skew module<a class="headerlink" href="#module-spatial.skew" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.skew.skew">
<span class="sig-prename descclassname"><span class="pre">spatial.skew.</span></span><span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_array</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/skew.html#skew"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.skew.skew" title="Link to this definition">¶</a></dt>
<dd><p>skew  convert 3D vector &lt;–&gt; 3x3 skew-symmetric matrix
S=skew(v) and v=skew(A) calculate the 3x3 skew-symmetric matrix S
corresponding to the given 3D vector v, and the 3D vector corresponding
to the skew-symmetric component of the given arbitrary 3x3 matrix A. For
vectors a and b, skew(a)*b is the cross product of a and b. If the
argument is a 3x3 matrix then it is assumed to be A, otherwise it is
assumed to be v. skew(A) produces a column-vector result, but skew(v)
will accept a row or column vector argument.</p>
</dd></dl>

</section>
<section id="module-spatial.xlt">
<span id="spatial-xlt-module"></span><h2>spatial.xlt module<a class="headerlink" href="#module-spatial.xlt" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="spatial.xlt.xlt">
<span class="sig-prename descclassname"><span class="pre">spatial.xlt.</span></span><span class="sig-name descname"><span class="pre">xlt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/spatial/xlt.html#xlt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#spatial.xlt.xlt" title="Link to this definition">¶</a></dt>
<dd><p>xlt  spatial coordinate transform (translation of origin).
xlt(r) calculates the coordinate transform matrix from A to B
coordinates for spatial motion vectors, in which frame B is translated by
an amount r (3D vector) relative to frame A. r can be a row or column vector.</p>
</dd></dl>

</section>
<section id="module-spatial">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-spatial" title="Link to this heading">¶</a></h2>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">pyspatial</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, PC.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/spatial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>